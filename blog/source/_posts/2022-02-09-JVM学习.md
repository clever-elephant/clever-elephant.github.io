---
title: JVM学习
date: 2022-02-09
tags: jvm
categories: Java学习
cover: /img/cover/jvm.jpg
---

# JVM学习

## 内存结构

### 1 程序计数器

#### 1 定义

> 程序计数器`Program Counter Register`是一小块的内存空间，可以看作是当前线程所执行的字节码的信号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器完成。物理层面上，程序计数器是通过寄存器实现的。

#### 2 作用

> 记住下一条jvm指令的执行地址

#### 3 特点

- 线程私有
- 不会存在内存溢出

### 2. 虚拟机栈

#### 1 定义

> 虚拟机栈`Java Virtual Machine Stack`描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧`Stack Frame`，栈帧里存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
>
> 如果线程请求的栈深度大于虚拟机所允许的深度，则会抛出`StackOverflowError`异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存则会抛出`OutofMemoryError`异常。

#### 2 特点

- 线程私有

#### 3 问题

- cpu占用过多

  定位：

  ```shell
  top #使用top命令定位哪个进程对cpu占用过高
  PID   COMMAND      %CPU  TIME     #TH    #WQ  #PORT MEM    PURG   CMPRS  PGRP
  1549  java         100.7 38:02.06 25/1   1    90    27M    0B     0B     557
  jstack 1549 
  2022-02-15 00:41:22
  Full thread dump OpenJDK 64-Bit Server VM (25.312-b07 mixed mode):
  
  "Attach Listener" #15 daemon prio=9 os_prio=31 tid=0x00000001190c1000 nid=0xa403 waiting on condition [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "DestroyJavaVM" #14 prio=5 os_prio=31 tid=0x000000011787b800 nid=0x2903 waiting on condition [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "Thread-1" #11 prio=5 os_prio=31 tid=0x00000001398bd000 nid=0xa803 runnable [0x000000016e786000]
     java.lang.Thread.State: RUNNABLE
  	at per.zida.jvm.Demo_1.lambda$main$0(Demo_1.java:12)
  	at per.zida.jvm.Demo_1$$Lambda$1/2128227771.run(Unknown Source)
  	at java.lang.Thread.run(Thread.java:748)
  
  "Service Thread" #10 daemon prio=9 os_prio=31 tid=0x0000000117819800 nid=0x4203 runnable [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "C1 CompilerThread3" #9 daemon prio=9 os_prio=31 tid=0x000000013b814000 nid=0x4003 waiting on condition [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "C2 CompilerThread2" #8 daemon prio=9 os_prio=31 tid=0x0000000139052000 nid=0x3e03 waiting on condition [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "C2 CompilerThread1" #7 daemon prio=9 os_prio=31 tid=0x0000000117808800 nid=0x4403 waiting on condition [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "C2 CompilerThread0" #6 daemon prio=9 os_prio=31 tid=0x0000000139881800 nid=0x4503 waiting on condition [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "Monitor Ctrl-Break" #5 daemon prio=5 os_prio=31 tid=0x000000013987e000 nid=0x3b03 runnable [0x000000016d932000]
     java.lang.Thread.State: RUNNABLE
  	at java.net.SocketInputStream.socketRead0(Native Method)
  	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
  	at java.net.SocketInputStream.read(SocketInputStream.java:171)
  	at java.net.SocketInputStream.read(SocketInputStream.java:141)
  	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
  	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
  	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
  	- locked <0x000000076af0fa38> (a java.io.InputStreamReader)
  	at java.io.InputStreamReader.read(InputStreamReader.java:184)
  	at java.io.BufferedReader.fill(BufferedReader.java:161)
  	at java.io.BufferedReader.readLine(BufferedReader.java:324)
  	- locked <0x000000076af0fa38> (a java.io.InputStreamReader)
  	at java.io.BufferedReader.readLine(BufferedReader.java:389)
  	at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:49)
  
  "Signal Dispatcher" #4 daemon prio=9 os_prio=31 tid=0x0000000139834800 nid=0x4603 runnable [0x0000000000000000]
     java.lang.Thread.State: RUNNABLE
  
  "Finalizer" #3 daemon prio=8 os_prio=31 tid=0x0000000119037800 nid=0x3203 in Object.wait() [0x000000016d402000]
     java.lang.Thread.State: WAITING (on object monitor)
  	at java.lang.Object.wait(Native Method)
  	- waiting on <0x000000076ab08ef0> (a java.lang.ref.ReferenceQueue$Lock)
  	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
  	- locked <0x000000076ab08ef0> (a java.lang.ref.ReferenceQueue$Lock)
  	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
  	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)
  
  "Reference Handler" #2 daemon prio=10 os_prio=31 tid=0x0000000119035000 nid=0x4c03 in Object.wait() [0x000000016d1f6000]
     java.lang.Thread.State: WAITING (on object monitor)
  	at java.lang.Object.wait(Native Method)
  	- waiting on <0x000000076ab06c08> (a java.lang.ref.Reference$Lock)
  	at java.lang.Object.wait(Object.java:502)
  	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
  	- locked <0x000000076ab06c08> (a java.lang.ref.Reference$Lock)
  	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)
  
  "VM Thread" os_prio=31 tid=0x0000000119030000 nid=0x3003 runnable 
  
  "ParGC Thread#0" os_prio=31 tid=0x0000000139010800 nid=0x2207 runnable 
  
  "ParGC Thread#1" os_prio=31 tid=0x000000013b808800 nid=0x2103 runnable 
  
  "ParGC Thread#2" os_prio=31 tid=0x000000013b809000 nid=0x2b03 runnable 
  
  "ParGC Thread#3" os_prio=31 tid=0x000000013b80a000 nid=0x5303 runnable 
  
  "ParGC Thread#4" os_prio=31 tid=0x000000013c008800 nid=0x5203 runnable 
  
  "ParGC Thread#5" os_prio=31 tid=0x000000013c009000 nid=0x2d03 runnable 
  
  "ParGC Thread#6" os_prio=31 tid=0x000000013c00a000 nid=0x2f03 runnable 
  
  "ParGC Thread#7" os_prio=31 tid=0x000000013c00a800 nid=0x4f03 runnable 
  
  "VM Periodic Task Thread" os_prio=31 tid=0x000000011781a800 nid=0x5603 waiting on condition 
  
  JNI global references: 321
  
  
  
  ```
  
  
  
  

### 3. 本地方法栈

> 本地方法栈`Native Method Stacks`与虚拟机栈所发挥的作用是类似的，区别是虚拟机栈执行Java方法，而本地方法栈则是为虚拟机使用到`Native`方法

### 4. Java堆

#### 1 定义

> Java堆`Java Heap`是虚拟机所管理的内存中最大的一块，此内存区域的唯一目的就是存放对象实例。Java堆即可以被实现固定大小的，也可以是可扩展的（通过`-Xmx`和`-Xms`设定）。如果在Java堆中没有内存完成实例的分配，并且堆也无法在扩展时，Java虚拟机则会抛出`OutOfMemoryError`异常。

#### 2 特点

- 线程共享的，堆中对象都需要线程安全的问题
- 有垃圾回收机制

### 5.方法区

#### 1 定义

> 方法区`Method Area`与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息，常量，静态变量，即使编译后的代码缓存等数据。如果方法区无法满足新的内存分配需求时，将抛出`OutOfMemeryError`异常。

### 6.

## 垃圾回收

### 1.引用计数法

### 2.可达性分析算法

在Java技术体系里，固定可作为GC Roots的对象包括：

- 在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
- 在方法区中常量引用的对象，譬如字符串常量池里的引用
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一类常驻的异常对象等，还有系统类加载器
- 所有被同步锁持有的对象
- <span style='blackground:red'>反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等</span>

> 即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程；如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。假如对象没有覆盖`finalize()`方法，或者`finalize（）`方法已经被虚拟机调用过了，那么虚拟机将这种情况都视为“没有必要执行”。

```java
/**
 * 此代码演示以下两点：
 * 1.对象可以在被GC时自救
 * 2.这种自救的机会只有一次，因为一个对象的finalize方法只能执行一次
 *
 * @author: wangzida
 * @create: 2022-02-21 22:12
 **/
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;


    public void isAlive() {
        System.out.println("Yes, I'm alive :)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Exception {
        SAVE_HOOK = new FinalizeEscapeGC();

        //对象第一次成功自救
        SAVE_HOOK = null;
        System.gc();
        //因为finalize方法执行优先级很低，暂停0.5s，以等待
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("No,I'm dead :(");
        }
        //与第一次代码相同，却拯救失败
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("No,I'm dead :(");
        }
    }


}
```





### 3.引用

- 强引用：是最传统的“引用”的定义，是指程序代码之中普遍存在的引用赋值，即类似`Objecjt obj = new Object()`这种关系。无论任何情况下，只要强引用关系还存在，垃圾回收器就永远不会回收调被引用的对象。
- 软引用：是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛内存溢出异常。在JDK1.2以后提供`SoftReference类`来实现软引用。
- 弱引用：是用来描述那些非必需的对象，它的强度比软引用更弱，被弱引用关联的对象只能生存到下次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在JDK1.2之后提供`WeakReference类`来实现弱引用。
- 虚引用：是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被回收器回收时收到一个系统通知。在JDK1.2之后提供`PhantomReference类`来实现虚引用。

#### 1 软引用应用

```java
public class SoftReferenceExample {

    public static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        //java.lang.OutOfMemoryError: Java heap space
        List<byte[]> list = new ArrayList<>();
        for (int i = 0; i <= 5; i++) {
            list.add(new byte[_4MB]);
        }
//        soft();
    }

    /**
     * 软引用
     */
    public static void soft() {
        //创建一个软引用队列
        ReferenceQueue<byte[]> queue = new ReferenceQueue<byte[]>();
        ArrayList<SoftReference<byte[]>> list = new ArrayList<>();
        for (int i = 0; i <= 5; i++) {
            //创建软引用，并关联队列。当byte[]被回收时，软引用会自动加入队列
            SoftReference<byte[]> ref = new SoftReference<byte[]>(new byte[_4MB], queue);
            System.err.println(ref);
            list.add(ref);
        }

        //将引用对象中的引用对象已经被垃圾回收器回收，从集合里去除
        Reference<? extends byte[]> poll = queue.poll();
        while (poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }
        System.err.println("program is end the list size is " + list.size());

        for (SoftReference<byte[]> ref : list) {
            System.err.println(ref.get());
        }
    }
}
```

### 4 分代回收

> 当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”`Generational Collection`的理论设计它建立在两个分代假说之上：
>
> - 弱分代假说：绝大多数对象都是朝生夕灭的
> - 强分代假说：熬过越多次垃圾收集过程的对象就越难以消灭

#### 1.回收类型：

- 部分收集`Partial GC`：指目标不是完整收集整个Java堆的垃圾，其中又分为：
  - 新生代收集`Minor GC /Young GC`：指目标只是新生代的垃圾收集。
  - 老年代收集`Major GC/Old GC`：指目标只是老年队的垃圾收集。
  - 混合收集`Mixed GC`：指目标时收集整个新生代以及部分老年代的垃圾收集。
- 整堆收集`Full GC`：收集整个Java堆和方法区的垃圾收集。

#### 2.标记-清除算法

> 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象。在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
>
> 缺点：
>
> - 执行效率不稳定
> - 内存空间碎片化问题

#### 3.标记-复制算法

> 算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后把自己已经使用的内存空间一次清理掉。
>
> 缺点：
>
> - 如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销
> - 将可用的内存缩小为原来的一半，内存空间造成浪费



