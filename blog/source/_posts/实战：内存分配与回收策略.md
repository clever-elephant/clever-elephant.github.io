---
title: 实战：内存分配与回收策略
date: 2022-02-25
tags: jvm
categories: Java学习
cover: /img/cover/jvm.jpg
---



# 实战：内存分配与回收策略

> Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。
>
> 对象的内存分配，从概念上讲，应该都是在堆上分配。在经典分代的设计下，新生的对象通常会分配在新生代中，少数情况下（例如对象大小超过一定阈值）也可能会直接分配在老年代。对象分配的规则并不是固定的，《Java虚拟机规范》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪一种垃圾收集器，以及虚拟机中于内存相关的参数的设定。

## 1.对象优先在Eden分配

大多数情况下，对象在新生代`Eden区`中分配。当`Eden区`没有足够空间进行分配时，虚拟机将发起一次`Minor GC`。

> `HotSpot虚拟机`提供`-XX:+PrintGCDetails`这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域分配情况。在实际问题排查中，收集器日志常会打印到文件后通过工具进行分析。

```java
    private static final int _1MB = 1024 * 1024;

    public static void testAllocation() {
        byte[] allocation1, allocation2, allocation3, allocation4;
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];//发生一次Minor GC
    }
```

运行结果：

```shell
[GC (Allocation Failure) [PSYoungGen: 7439K->736K(9216K)] 7439K->4840K(23552K), 0.0043710 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 2950K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 8192K, 27% used [0x00000007bf600000,0x00000007bf829878,0x00000007bfe00000)
  from space 1024K, 71% used [0x00000007bfe00000,0x00000007bfeb8000,0x00000007bff00000)
  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)
 ParOldGen       total 14336K, used 4104K [0x00000007be800000, 0x00000007bf600000, 0x00000007bf600000)
  object space 14336K, 28% used [0x00000007be800000,0x00000007bec02020,0x00000007bf600000)
 Metaspace       used 3215K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 346K, capacity 388K, committed 512K, reserved 1048576K
```

## 2.大对象直接进入老年代

大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。大对象对虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到坏消息更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应注意避免。在Java虚拟机中要避免大对象的原因时，在分配空间时，它容易导致内存明明还有不少空间时就提前出发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。HotSpot虚拟机提供了`-XX:PretenureSizeThreshold`参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在`Eden区`以及两个`Survivor区`之间来回复制，产生大量的内存复制操作。

```java
    //-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -verbose:gc -XX:SurvivorRatio=8 -XX:UseSerialGC -XX:PretenureSizeThreshold=3145728
    private static final int _1MB = 1024 * 1024;
    public static void testPretenureSizeThreshold() {
        byte[] allocation;
        allocation = new byte[4 * _1MB];
    }
```

运行结果：



## 3.长期存活的对象将进入老年代

HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为能做到这点，虚拟机给每个对象定义了一个对象年龄`Age`计数器，存储在对象头中。对象通常在`Eden区`诞生，如果经过第一次` Minor GC`后仍然存活，并且能被`Survivor区`容纳的话，对象会被移动到`Survivor区`，并且将其对象年龄设为1岁。对象在`Survivor区`每熬过一次`Minor GC`，年龄就会加1，当它的年龄增加到一定程度(默认为15),就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`设置。

```java
    
//-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -verbose:gc -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1
    public static void testTenuringThreshold() {
        byte[] allocation1, allocation2, allocation3;
        allocation1 = new byte[_1MB / 4];
        allocation2 = new byte[4 * _1MB];
        allocation3 = new byte[4 * _1MB];
        allocation3 = null;
        allocation3 = new byte[4 * _1MB];
    }
```

运行结果：

```shell
[GC (Allocation Failure) [PSYoungGen: 7358K->992K(9216K)] 7358K->5150K(23552K), 0.0010394 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 9216K, used 2180K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 8192K, 14% used [0x00000007bf600000,0x00000007bf729100,0x00000007bfe00000)
  from space 1024K, 96% used [0x00000007bfe00000,0x00000007bfef8010,0x00000007bff00000)
  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)
 ParOldGen       total 14336K, used 4158K [0x00000007be800000, 0x00000007bf600000, 0x00000007bf600000)
  object space 14336K, 29% used [0x00000007be800000,0x00000007bec0fa68,0x00000007bf600000)
 Metaspace       used 3141K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K
```

